# Strategy Compiler - Work Packet

## Overview

Build a Python module that converts MoneyFace StrategySpec JSON format into executable QuantConnect Lean (QCL) algorithm files. The compiler must parse the JSON strategy specification and generate properly formatted Python code that runs on the QuantConnect Lean engine.

## Objectives

1. Parse and validate StrategySpec JSON files
2. Generate syntactically correct QCL Python algorithms
3. Support all StrategySpec node types and conditions
4. Create custom indicators as needed
5. Produce black-formatted, production-ready code

## Technical Requirements

### Environment
- Python 3.11+
- Dependencies allowed: 
  - `pydantic` (for JSON validation)
  - `black` (for code formatting)
  - Standard library only for core functionality
- Testing framework: pytest
- Code style: Black formatted, PEP 8 compliant
- Note: QuantConnect account is NOT required for the compiler itself

### Performance Requirements
- Compilation time: < 5 seconds for strategies up to 1000 nodes
- Memory usage: < 500MB for typical strategies
- Must handle deeply nested logic (up to 10 levels)

## Input Specification

### StrategySpec JSON Format
See `../sample_data/` for example strategies and the full schema at `strategy_spec_v1_schema.json`.

Key elements to support:
- **Node Types**: condition, filter, order, exit, expression, weight, group
- **Conditions**: All indicators listed in schema (sma, ema, rsi, returns, etc.)
- **Operators**: gt, gte, lt, lte, eq, neq, crosses_above, crosses_below
- **Parameters**: Support for parameterized values using `${param_id}` syntax
- **Universes**: Dynamic asset selection and filtering

### Input Processing Rules
- **Case Sensitivity**: All string values (operators, conditions, node types) are case-insensitive
- **Comments**: Support `#` for single-line comments (ignored during parsing)
- **Duplicate Keys**: Raise an error if duplicate keys appear in the same object

## Output Specification

### Generated QCL Algorithm Structure
```python
# Generated by MoneyFace Strategy Compiler v1.0
# Strategy: {strategy_name}
# Generated: {timestamp}

from AlgorithmImports import *
from typing import Dict, List, Optional
import numpy as np


class {ClassName}(QCAlgorithm):
    """
    {strategy_description}
    """
    
    def Initialize(self) -> None:
        """Initialize algorithm parameters and universe"""
        # Set start/end dates
        self.SetStartDate({start_year}, {start_month}, {start_day})
        self.SetEndDate({end_year}, {end_month}, {end_day})
        
        # Set cash
        self.SetCash({capital})
        
        # Set benchmark
        self.SetBenchmark("{benchmark}")
        
        # Initialize parameters
        {parameter_initialization}
        
        # Add universe
        {universe_setup}
        
        # Set rebalance schedule
        {rebalance_schedule}
        
        # Initialize indicators
        {indicator_setup}
        
        # Set fee model
        {fee_model}
        
        # Set slippage model
        {slippage_model}
    
    def OnData(self, data: Slice) -> None:
        """Main algorithm logic executed on each data point"""
        {main_logic}
    
    # Custom methods as needed
    {custom_methods}
```

### Directory Structure
```
output/
├── algorithm.py          # The generated QCL algorithm
├── config.json          # Lean configuration file
├── requirements.txt     # Runtime dependencies (if any)
└── metadata.json        # Compilation metadata
```

## Deliverables

### 1. Core Module (`strategy_compiler.py`)
Main compiler class with methods:
- `compile_strategy(strategy_spec: dict) -> CompilationResult`
- `validate_spec(strategy_spec: dict) -> ValidationResult`
- `generate_algorithm_file(strategy_spec: dict, output_dir: str) -> None`

### 2. Code Generators (`generators/`)
- `node_generator.py` - Convert logic nodes to Python code
- `indicator_generator.py` - Generate indicator setup and calculations
- `order_generator.py` - Generate order placement logic
- `universe_generator.py` - Generate universe selection code

### 3. Custom Indicators (`indicators/`)
Implement any indicators not available in QCL:
- Cross-sectional momentum rankers
- Custom moving averages
- Regime detection indicators

### 4. Tests (`tests/`)
- Unit tests for each component (>90% coverage)
- Integration tests with sample strategies
- Generated code validation tests

### 5. Documentation
- `DESIGN.md` - Technical design decisions
- `API.md` - Module API documentation
- `EXAMPLES.md` - Usage examples

## Acceptance Tests

### 1. Compilation Tests
```python
def test_compile_simple_buy_hold():
    """Test compilation of simple buy-and-hold strategy"""
    with open("../sample_data/simple_buy_hold.json") as f:
        spec = json.load(f)
    
    result = compiler.compile_strategy(spec)
    
    assert result.success == True
    assert "class SimpleBuyAndHoldSPY" in result.code
    assert "self.SetCash(10000)" in result.code
    assert result.errors == []
```

### 2. Code Execution Tests
```python
def test_generated_code_runs():
    """Test that generated code executes without errors"""
    # Compile strategy
    result = compiler.compile_strategy(spec)
    
    # Write to temp file
    with open("temp_algo.py", "w") as f:
        f.write(result.code)
    
    # Import and instantiate (mock QCAlgorithm)
    # Should not raise any exceptions
    algo = load_algorithm("temp_algo.py")
    algo.Initialize()
```

### 3. Logic Verification Tests
Test each node type generates correct code:
- Condition nodes → if statements
- Filter nodes → universe selection
- Order nodes → SetHoldings() calls
- Exit nodes → Liquidate() calls

### 4. Validation Tests
```python
def test_case_insensitive_parsing():
    """Test that all values are parsed case-insensitively"""
    spec = {
        "logic": {
            "type": "CONDITION",  # uppercase
            "lhs": {"type": "indicator", "name": "SMA"},
            "operator": "CROSSES_ABOVE",  # uppercase
            "rhs": {"type": "indicator", "name": "ema"}
        }
    }
    result = compiler.compile_strategy(spec)
    assert result.success == True

def test_duplicate_key_error():
    """Test that duplicate keys raise an error"""
    # JSON with duplicate keys should be caught during parsing
    result = compiler.compile_strategy(duplicate_key_spec)
    assert result.success == False
    assert "duplicate key" in result.errors[0]["message"].lower()

def test_cross_validation():
    """Test cross-field validation rules"""
    # Reference undefined indicator
    spec = create_spec_with_undefined_indicator()
    result = compiler.compile_strategy(spec)
    assert result.success == False
    assert "undefined indicator" in result.errors[0]["message"].lower()
```

### 5. Performance Tests
```python
def test_compilation_performance():
    """Test compilation completes within time limit"""
    large_strategy = generate_large_strategy(nodes=1000)
    
    start = time.time()
    result = compiler.compile_strategy(large_strategy)
    duration = time.time() - start
    
    assert duration < 5.0  # Must complete in 5 seconds
    assert result.success == True
```

## Integration Instructions

### For MoneyFace Engineers

1. **Installation**
   ```bash
   # Install in development mode
   pip install -e ".[dev]"
   
   # Or just core dependencies
   pip install -e .
   ```

2. **Usage in your system**
   ```python
   from strategy_compiler import StrategyCompiler
   
   # Initialize compiler
   compiler = StrategyCompiler()
   
   # Load strategy from your database
   strategy_spec = load_strategy_from_db(strategy_id)
   
   # Compile to QCL
   result = compiler.compile_strategy(strategy_spec)
   
   if result.success:
       # Save generated files
       save_algorithm(result.code, result.config)
   else:
       # Handle compilation errors
       log_errors(result.errors)
   ```

3. **Output Files**
   - Generated `algorithm.py` → QuantConnect Lean algorithm
   - Generated `config.json` → Lean configuration
   - `metadata.json` → Track compilation details

4. **Error Handling**
   The compiler returns detailed error information with line/column numbers:
   ```python
   {
       "success": false,
       "errors": [
           {
               "type": "InvalidNode",
               "message": "Unknown condition type: 'custom_indicator'",
               "location": "logic.children[0].lhs.name",
               "line": 45,
               "column": 12
           }
       ]
   }
   ```
   
   **Required Validations**:
   - All indicators in rules must be defined in the strategy
   - Exit rules must reference valid entry positions
   - Numeric parameters must be within valid ranges
   - Position sizes must sum to ≤ 100%
   - Duplicate keys within objects must be caught

## Testing Your Implementation

Run the test suite:
```bash
pytest tests/ -v --cov=strategy_compiler --cov-report=html
```

Validate against sample strategies:
```bash
python validate_samples.py ../sample_data/
```

## Questions/Clarifications

If you need clarification on any requirement, assume:
1. Use QCL's built-in indicators where possible
2. Generate verbose, readable code (not minified)
3. Include helpful comments in generated code
4. Prefer correctness over optimization
5. When in doubt, follow QCL's example algorithms

## Sample Generated Code

See `examples/` directory for sample outputs from each test strategy.