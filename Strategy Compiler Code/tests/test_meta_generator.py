"""
Unit tests for MetaGenerator class.
"""

import pytest
import json
import re
from datetime import datetime
from pathlib import Path

from meta_generator import MetaGenerator


class TestMetaGenerator:
    """Test class for MetaGenerator functionality."""
    
    def test_initialization(self, meta_generator):
        """Test MetaGenerator initialization."""
        assert meta_generator.compiler_version == "1.0"
        assert meta_generator.compilation_timestamp is None
        
    def test_generate_class_name_simple(self, meta_generator):
        """Test class name generation with simple cases."""
        assert meta_generator.generate_class_name("Simple Strategy") == "SimpleStrategy"
        assert meta_generator.generate_class_name("my_strategy") == "MyStrategy"
        assert meta_generator.generate_class_name("TEST") == "Test"
        
    def test_generate_class_name_special_characters(self, meta_generator):
        """Test class name generation with special characters."""
        assert meta_generator.generate_class_name("BB-XM NASDAQ-X ||| Deez ||| 29JUN2023") == "BbXmNasdaqXDeez29jun2023"
        assert meta_generator.generate_class_name("Strategy@#$%^&*()Name") == "StrategyName"
        assert meta_generator.generate_class_name("Test-123_Strategy!") == "Test123Strategy"
        
    def test_generate_class_name_edge_cases(self, meta_generator):
        """Test class name generation with edge cases."""
        assert meta_generator.generate_class_name("") == "GeneratedStrategy"
        assert meta_generator.generate_class_name(None) == "GeneratedStrategy"
        assert meta_generator.generate_class_name("123NumbersFirst") == "Strategy123numbersfirst"
        assert meta_generator.generate_class_name("   Spaces   ") == "Spaces"
        
    def test_generate_class_name_parametrized(self, meta_generator, class_name_test_cases):
        """Test class name generation with parametrized test cases."""
        result = meta_generator.generate_class_name(class_name_test_cases)
        
        # Verify result is a valid Python identifier or fallback
        if result != "GeneratedStrategy":
            # Should be alphanumeric and start with letter
            assert result.replace('_', '').isalnum() or result[0].isalpha()
            
    def test_generate_header_comment_full(self, meta_generator, sample_meta_full):
        """Test header comment generation with full metadata."""
        header = meta_generator.generate_header_comment(sample_meta_full)
        
        assert "Generated by MoneyFace Strategy Compiler v1.0" in header
        assert f"Strategy: {sample_meta_full['name']}" in header
        assert f"Version: {sample_meta_full['version']}" in header
        assert f"Category: {sample_meta_full['category']}" in header
        assert f"Source: {sample_meta_full['source']} ({sample_meta_full['source_id']})" in header
        assert "Generated:" in header
        
        # Verify timestamp is set
        assert meta_generator.compilation_timestamp is not None
        
    def test_generate_header_comment_minimal(self, meta_generator, sample_meta_minimal):
        """Test header comment generation with minimal metadata."""
        header = meta_generator.generate_header_comment(sample_meta_minimal)
        
        assert "Generated by MoneyFace Strategy Compiler v1.0" in header
        assert f"Strategy: {sample_meta_minimal['name']}" in header
        assert "Generated:" in header
        
        # Version is a required field, so it should appear if present
        assert f"Version: {sample_meta_minimal['version']}" in header
        
        # Should not contain truly optional fields
        assert "Category:" not in header
        assert "Source:" not in header
        
    def test_generate_class_docstring_full(self, meta_generator, sample_meta_full):
        """Test class docstring generation with full metadata."""
        docstring = meta_generator.generate_class_docstring(sample_meta_full)
        
        assert sample_meta_full['description'] in docstring
        assert f"Category: {sample_meta_full['category']}" in docstring
        assert f"Version: {sample_meta_full['version']}" in docstring
        assert f"Complexity Score: {sample_meta_full['complexity_score']}" in docstring
        
    def test_generate_class_docstring_minimal(self, meta_generator, sample_meta_minimal):
        """Test class docstring generation with minimal metadata."""
        docstring = meta_generator.generate_class_docstring(sample_meta_minimal)
        
        # Should use default description
        assert "Generated trading strategy" in docstring
        
    def test_generate_config_metadata_basic(self, meta_generator, sample_meta_with_description):
        """Test config metadata generation."""
        config = meta_generator.generate_config_metadata(sample_meta_with_description)
        
        assert config["algorithm-type-name"] == "MomentumStrategy"
        assert config["algorithm-language"] == "Python"
        assert config["algorithm-location"] == "algorithm.py"
        assert config["algorithm-version"] == sample_meta_with_description["version"]
        
    def test_generate_config_metadata_no_version(self, meta_generator):
        """Test config metadata generation without version."""
        meta = {"name": "Test Strategy"}
        config = meta_generator.generate_config_metadata(meta)
        
        assert "algorithm-version" not in config
        
    def test_generate_compilation_metadata_complete(self, meta_generator, sample_meta_full):
        """Test compilation metadata generation with complete data."""
        metadata = meta_generator.generate_compilation_metadata(sample_meta_full)
        
        # Check strategy section
        strategy = metadata["strategy"]
        assert strategy["name"] == sample_meta_full["name"]
        assert strategy["description"] == sample_meta_full["description"]
        assert strategy["version"] == sample_meta_full["version"]
        assert strategy["category"] == sample_meta_full["category"]
        assert strategy["source"] == sample_meta_full["source"]
        assert strategy["source_id"] == sample_meta_full["source_id"]
        assert strategy["source_url"] == sample_meta_full["source_url"]
        assert strategy["complexity_score"] == sample_meta_full["complexity_score"]
        
        # Check compilation section
        compilation = metadata["compilation"]
        assert compilation["compiler_version"] == "1.0"
        assert "timestamp" in compilation
        assert "generated_files" in compilation
        assert len(compilation["generated_files"]) == 4
        
        # Check original meta section
        original = metadata["original_meta"]
        assert original["created_at"] == sample_meta_full["created_at"]
        assert original["updated_at"] == sample_meta_full["updated_at"]
        
    def test_generate_compilation_metadata_minimal(self, meta_generator, sample_meta_minimal):
        """Test compilation metadata generation with minimal data."""
        metadata = meta_generator.generate_compilation_metadata(sample_meta_minimal)
        
        # Should only contain available fields
        strategy = metadata["strategy"]
        assert "name" in strategy
        assert "description" not in strategy
        assert "category" not in strategy
        
        # Should not have original_meta section
        assert "original_meta" not in metadata
        
    def test_process_meta_complete(self, meta_generator, sample_meta_full):
        """Test complete meta processing."""
        result = meta_generator.process_meta(sample_meta_full)
        
        # Check all required keys are present
        expected_keys = {
            "class_name", "header_comment", "class_docstring", 
            "config_metadata", "compilation_metadata", "original_meta"
        }
        assert set(result.keys()) == expected_keys
        
        # Spot check some values
        assert result["class_name"] == "BbXmNasdaqXDeez29jun2023"
        assert isinstance(result["config_metadata"], dict)
        assert isinstance(result["compilation_metadata"], dict)
        assert result["original_meta"] == sample_meta_full
                
    def test_timestamp_consistency(self, meta_generator, sample_meta_minimal):
        """Test that timestamp is consistent across multiple calls."""
        # First call sets the timestamp
        result1 = meta_generator.process_meta(sample_meta_minimal)
        
        # Second call should use the same timestamp
        result2 = meta_generator.process_meta(sample_meta_minimal)
        
        # Extract timestamps from results
        timestamp1 = meta_generator.compilation_timestamp
        timestamp2 = meta_generator.compilation_timestamp
        
        assert timestamp1 == timestamp2


class TestMetaGeneratorIntegration:
    """Integration tests using real sample data."""
    
    def test_with_real_sample_data(self, meta_generator):
        """Test MetaGenerator with actual sample strategy data."""
        # This is the actual meta from the sample file
        real_sample_meta = {
            "name": "BB-XM NASDAQ-X ||| Deez ||| 29JUN2023",
            "description": "Believe",
            "version": "1.0",
            "source": "composer",
            "source_id": "1hoPN3tFE0aDY3aiZtxT",
            "source_url": "https://app.composer.trade/symphony/1hoPN3tFE0aDY3aiZtxT/details",
            "category": "tactical",
            "complexity_score": 9,
            "created_at": "2025-06-25T03:37:14.947339Z",
            "updated_at": "2025-06-25T03:37:14.947363Z"
        }
        
        result = meta_generator.process_meta(real_sample_meta)
        
        # Verify the expected transformations
        assert result["class_name"] == "BbXmNasdaqXDeez29jun2023"
        assert "Believe" in result["class_docstring"]
        assert "tactical" in result["header_comment"]
        assert result["config_metadata"]["algorithm-type-name"] == "BbXmNasdaqXDeez29jun2023"
        
    def test_json_serialization(self, meta_generator, sample_meta_full):
        """Test that all generated data can be JSON serialized."""
        result = meta_generator.process_meta(sample_meta_full)
        
        # These should be JSON serializable
        json.dumps(result["config_metadata"])
        json.dumps(result["compilation_metadata"])
        
        # String outputs should be valid
        assert isinstance(result["class_name"], str)
        assert isinstance(result["header_comment"], str)
        assert isinstance(result["class_docstring"], str)