# Generated by MoneyFace Strategy Compiler v1.0
# Strategy: SSO, Energy, Chips, Commodities ? (Invest Copy)
# Generated: 2025-09-09 13:06:09 UTC
# Version: 1.0
# Category: tactical
# Source: composer (tCu5bdNyx1cSriFS1KVJ)
from AlgorithmImports import *
from typing import Dict, List, Optional
import numpy as np

from System import TimeSpan
from datetime import datetime, timedelta
from QuantConnect.Orders.Fees import FeeModel
from datetime import datetime

# -------- Fee Models --------
# Per order, per share, percentage fee model custom classes definitions (do not manipulate it)
class PerOrderFeeModel(FeeModel):
    """Fixed fee per order, regardless of size."""
    def __init__(self, fee: float = 1.0):
        self.fee = float(fee)

    def GetOrderFee(self, parameters: OrderFeeParameters) -> OrderFee:
        security = parameters.Security
        return OrderFee(CashAmount(self.fee, security.QuoteCurrency.Symbol))

class PerShareFeeModel(FeeModel):
    """Fee = fee_per_share * quantity traded."""
    def __init__(self, fee_per_share: float = 0.005):
        self.fee_per_share = float(fee_per_share)

    def GetOrderFee(self, parameters: OrderFeeParameters) -> OrderFee:
        security = parameters.Security
        order = parameters.Order
        quantity = abs(order.AbsoluteQuantity)   
        fee_amount = self.fee_per_share * quantity
        return OrderFee(CashAmount(fee_amount, security.QuoteCurrency.Symbol))

class PercentageFeeModel(FeeModel):
    """Fee = percentage_of_trade_value * |trade value|."""
    def __init__(self, rate: float = 0.0005):
        if rate < 0 or rate > 1:
            raise ValueError("Percentage fee must be between 0 and 1")
        self.rate = float(rate)

    def GetOrderFee(self, parameters: OrderFeeParameters) -> OrderFee:
        security = parameters.Security
        order = parameters.Order
        trade_value_quote = abs(order.GetValue(security))  # in quote currency
        fee_amount = trade_value_quote * self.rate
        return OrderFee(CashAmount(fee_amount, security.QuoteCurrency.Symbol))


# -------- Slippage Models --------
# Fixed, percentage, volume impact slippage model custom classes definitions (do not manipulate it)
class FixedSlippageModel:
    """Fixed slippage model."""
    def __init__(self, value: float = 0.01):
        self.value = float(value)
    def GetSlippageApproximation(self, asset: Security, order: Order) -> float:
        return self.value

class PercentageSlippageModel:
    """Percentage slippage model."""
    def __init__(self, value: float = 0.0005):
        if not (0 <= value <= 1):
            raise ValueError("Percentage slippage must be between 0 and 1")
        self.value = float(value)
    def GetSlippageApproximation(self, asset: Security, order: Order) -> float:
        return asset.Price * self.value

class VolumeImpactSlippageModel:
    """Volume impact slippage model."""
    def __init__(self, value: float = 0.1):
        self.value = float(value)
    def GetSlippageApproximation(self, asset: Security, order: Order) -> float:
        vol = max(asset.Volume, 1)
        qty = abs(order.AbsoluteQuantity)
        return asset.Price * self.value * (qty / vol)

class SsoEnergyChipsCommoditiesInvestCopy(QCAlgorithm):
    '''
    
    
    Category: tactical
    Version: 1.0
    Complexity Score: 4
    '''

    def rebalance(self):
        '''
        Equal-weight rebalance across all currently invested positions.

        Behavior:
        - Finds all symbols with non-zero holdings (Portfolio[x].Invested == True).
        - If any are invested, sets each to an equal target weight of 1/N.
        - Uses SetHoldings(...) so Lean submits the necessary orders to reach targets.
        - Emits a Debug line summarizing the action.

        Side effects:
        - May place market orders and change portfolio exposure.

        Returns:
        - None
        '''
    
        # Collect currently invested symbols (positions with non-zero holdings)
        invested_symbols = [p.Symbol for p in self.Portfolio.Values if p.Invested]

        # If nothing is invested, skip rebalancing to avoid unnecessary orders
        if not invested_symbols:
            self.Debug("Rebalance skipped: no invested positions")
            return

        # Target equal weight for each invested symbol
        weight = 1.0 / len(invested_symbols)

        # Bring each position to the target weight
        for symbol in invested_symbols:
            # SetHoldings adjusts the position to the given portfolio weight
            self.SetHoldings(symbol, weight)

        # Log a concise summary for debugging/audit
        self.Debug(f"Rebalanced equally across {len(invested_symbols)} positions at {weight:.2%} each")

    def initialize(self):

        # Set initial capital
        self.SetCash(100000.0)
        
        # Set backtest start date
        self.SetStartDate(datetime.strptime('2012-04-02', '%Y-%m-%d'))

        # Set backtest end date
        self.SetEndDate(datetime.strptime('2025-09-09', '%Y-%m-%d'))
        
        # Set custom transaction fees
        # Set percentage-based fees
        fee_model = PercentageFeeModel(0.001)
        
        # Set slippage model
        slippage_model = PercentageSlippageModel(0.001)
        

        # wrap brokerage defaults + fee model + slippage model
        def init_sec(security: Security):
            security.SetFeeModel(fee_model)
            security.SetSlippageModel(slippage_model)
        
        self.SetSecurityInitializer(init_sec)
        
        # Schedule daily rebalancing
        self.Schedule.On(self.DateRules.EveryDay(), self.TimeRules.BeforeMarketClose('SPY', 30), self.rebalance)

        # Add securities to universe and store symbol references
        self.vixm_symbol = self.AddEquity("VIXM", Resolution.Daily).Symbol
        self.soxx_symbol = self.AddEquity("SOXX", Resolution.Daily).Symbol
        self.nvda_symbol = self.AddEquity("NVDA", Resolution.Daily).Symbol
        self.amd_symbol = self.AddEquity("AMD", Resolution.Daily).Symbol
        self.sso_symbol = self.AddEquity("SSO", Resolution.Daily).Symbol
        self.dbc_symbol = self.AddEquity("DBC", Resolution.Daily).Symbol
        self.xle_symbol = self.AddEquity("XLE", Resolution.Daily).Symbol
        self.enph_symbol = self.AddEquity("ENPH", Resolution.Daily).Symbol

        self.symbols = ['VIXM', 'SOXX', 'NVDA', 'AMD', 'SSO', 'DBC', 'XLE', 'ENPH']        # Initialize indicators with automatic warm-up support
        self.settings.automatic_indicator_warm_up = True

        self.vixm_rsi_40 = self.rsi('VIXM', 40)
        self.soxx_roc_90 = self.roc('SOXX', 90)
        self.nvda_roc_90 = self.roc('NVDA', 90)
        self.amd_roc_90 = self.roc('AMD', 90)
        self.sso_roc_90 = self.roc('SSO', 90)
        self.dbc_roc_90 = self.roc('DBC', 90)
        self.xle_roc_90 = self.roc('XLE', 90)
        self.enph_roc_90 = self.roc('ENPH', 90)

    def OnData(self, data: Slice) -> None:
        '''Main algorithm logic executed on each data point'''
        # Black Swan Catcher
        # Conditional logic 1
        # Condition: relative-strength-index gt 69
        if (self.vixm_rsi_40.current.value) > 69.0:
            # ProShares VIX Mid-Term Futures ETF
            if self._is_security_ready_for_trading('VIXM'):
                self.SetHoldings('VIXM', 1.0)
        else:
            # Rotator
            # Select top 1 by moving-average-return
            symbol_scores = {}
            if 'SOXX' in self.Securities:
                symbol_scores['SOXX'] = (self.soxx_roc_90.current.value)
            if 'NVDA' in self.Securities:
                symbol_scores['NVDA'] = (self.nvda_roc_90.current.value)
            if 'AMD' in self.Securities:
                symbol_scores['AMD'] = (self.amd_roc_90.current.value)
            if 'SSO' in self.Securities:
                symbol_scores['SSO'] = (self.sso_roc_90.current.value)
            if 'DBC' in self.Securities:
                symbol_scores['DBC'] = (self.dbc_roc_90.current.value)
            if 'XLE' in self.Securities:
                symbol_scores['XLE'] = (self.xle_roc_90.current.value)
            if 'ENPH' in self.Securities:
                symbol_scores['ENPH'] = (self.enph_roc_90.current.value)
            selected_symbols = sorted(symbol_scores.items(), key=lambda x: x[1], reverse=True)[:1]
            for symbol, score in selected_symbols:
                if self._is_security_ready_for_trading(symbol):
                    weights = {'SOXX': 1.0, 'NVDA': 1.0, 'AMD': 1.0, 'SSO': 1.0, 'DBC': 1.0, 'XLE': 1.0, 'ENPH': 1.0}
                    weight = weights.get(symbol, 0)
                    if weight > 0:
                        self.SetHoldings(symbol, weight)


    def _is_security_ready_for_trading(self, symbol: str) -> bool:
        '''Check if security is ready for trading with accurate price data.'''
        # Check if symbol exists in securities
        if symbol not in self.Securities:
            return False
        
        # Check if current slice contains data for this symbol
        if not self.current_slice or not self.current_slice.contains_key(symbol):
            return False
            
        # Check if slice data is not None
        if not self.current_slice[symbol]:
            return False
            
        # Check if security has valid price
        security = self.Securities[symbol]
        if not hasattr(security, 'Price') or security.Price <= 0:
            return False
            
        return True
            