import re
import json
from datetime import datetime
from typing import Dict, Any, Optional
from pathlib import Path


class MetaGenerator:
    """
    Generates metadata-related code and configuration for QCL algorithms.
    
    Processes the meta property from StrategySpec JSON and provides formatted
    output for algorithm.py, config.json, and metadata.json files.
    """
    
    def __init__(self):
        """Initialize the MetaGenerator with default settings."""
        self.compiler_version = "1.0"
        self.compilation_timestamp = None
        
    def generate_class_name(self, name: str) -> str:
        """
        Convert strategy name to valid Python class name (PascalCase).
        
        Args:
            name: Original strategy name from meta.name
            
        Returns:
            Sanitized Python class name in PascalCase
            
        Example:
            "BB-XM NASDAQ-X ||| Deez ||| 29JUN2023" -> "BBXMNASDAQXDeez29JUN2023"
        """
        if not name or not isinstance(name, str):
            return "GeneratedStrategy"
            
        # Split on any non-alphanumeric character to separate words
        words = re.split(r'[^a-zA-Z0-9]+', name)
        
        # Filter out empty strings and capitalize each word
        pascal_case = ''.join(word.capitalize() for word in words if word)
        
        # Ensure it starts with a letter (prepend 'Strategy' if it starts with number)
        if pascal_case and pascal_case[0].isdigit():
            pascal_case = "Strategy" + pascal_case
            
        # Fallback if empty after processing
        return pascal_case if pascal_case else "GeneratedStrategy"
    
    def generate_header_comment(self, meta: Dict[str, Any]) -> str:
        """
        Generate file header with strategy metadata and timestamp.
        
        Args:
            meta: Meta property dictionary from StrategySpec
            
        Returns:
            Formatted header comment block
        """
        if self.compilation_timestamp is None:
            self.compilation_timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
            
        lines = [
            f"# Generated by MoneyFace Strategy Compiler v{self.compiler_version}",
            f"# Strategy: {meta.get('name', 'Unknown Strategy')}",
            f"# Generated: {self.compilation_timestamp}"
        ]
        
        # Add optional fields if present
        if 'version' in meta:
            lines.append(f"# Version: {meta['version']}")
            
        if 'category' in meta:
            lines.append(f"# Category: {meta['category']}")
            
        if 'source' in meta:
            source_info = meta['source']
            if 'source_id' in meta:
                source_info += f" ({meta['source_id']})"
            lines.append(f"# Source: {source_info}")
            
        return "\n".join(lines)
    
    def generate_class_docstring(self, meta: Dict[str, Any]) -> str:
        """
        Generate class docstring with description and metadata.
        
        Args:
            meta: Meta property dictionary from StrategySpec
            
        Returns:
            Formatted class docstring content (without triple quotes)
        """
        lines = []
        
        # Primary description
        description = meta.get('description', 'Generated trading strategy')
        lines.append(description)
        
        # Add metadata if available
        metadata_lines = []
        if 'category' in meta:
            metadata_lines.append(f"Category: {meta['category']}")
            
        if 'version' in meta:
            metadata_lines.append(f"Version: {meta['version']}")
            
        if 'complexity_score' in meta:
            metadata_lines.append(f"Complexity Score: {meta['complexity_score']}")
            
        if metadata_lines:
            lines.append("")  # Empty line separator
            lines.extend(metadata_lines)
            
        return "\n    ".join(lines)
    
    def generate_config_metadata(self, meta: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate metadata for Lean configuration file.
        
        Args:
            meta: Meta property dictionary from StrategySpec
            
        Returns:
            Dictionary containing config.json relevant metadata
        """
        class_name = self.generate_class_name(meta.get('name', ''))
        
        config_data = {
            "algorithm-type-name": class_name,
            "algorithm-language": "Python",
            "algorithm-location": "algorithm.py"
        }
        
        # Add version if available
        if 'version' in meta:
            config_data["algorithm-version"] = meta['version']
            
        return config_data
    
    def generate_compilation_metadata(self, meta: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate comprehensive metadata for tracking file.
        
        Args:
            meta: Meta property dictionary from StrategySpec
            
        Returns:
            Dictionary containing complete metadata.json content
        """
        if self.compilation_timestamp is None:
            self.compilation_timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
            
        # Strategy metadata (preserve all original fields)
        strategy_meta = {}
        core_fields = ['name', 'description', 'version', 'category']
        for field in core_fields:
            if field in meta:
                strategy_meta[field] = meta[field]
                
        # Source tracking
        source_fields = ['source', 'source_id', 'source_url']
        for field in source_fields:
            if field in meta:
                strategy_meta[field] = meta[field]
                
        # Metrics and scores
        if 'complexity_score' in meta:
            strategy_meta['complexity_score'] = meta['complexity_score']
            
        # Compilation metadata
        compilation_meta = {
            "timestamp": self.compilation_timestamp,
            "compiler_version": self.compiler_version,
            "generated_files": ["algorithm.py", "config.json", "requirements.txt", "metadata.json"]
        }
        
        # Original lifecycle metadata
        original_meta = {}
        lifecycle_fields = ['created_at', 'updated_at']
        for field in lifecycle_fields:
            if field in meta:
                original_meta[field] = meta[field]
                
        metadata = {
            "strategy": strategy_meta,
            "compilation": compilation_meta
        }
        
        if original_meta:
            metadata["original_meta"] = original_meta
            
        return metadata
    
    def process_meta(self, meta: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main method that processes meta property and returns all generated components.
        
        Args:
            meta: Meta property dictionary from StrategySpec
            
        Returns:
            Dictionary containing all processed meta information:
            {
                "class_name": str,
                "header_comment": str,
                "class_docstring": str,
                "config_metadata": dict,
                "compilation_metadata": dict,
                "original_meta": dict
            }
        """
        # Note: Validation is handled by StrategyCompiler, so we assume meta is valid
        
        # Generate all components
        processed_meta = {
            "class_name": self.generate_class_name(meta['name']),
            "header_comment": self.generate_header_comment(meta),
            "class_docstring": self.generate_class_docstring(meta),
            "config_metadata": self.generate_config_metadata(meta),
            "compilation_metadata": self.generate_compilation_metadata(meta),
            "original_meta": meta.copy()
        }
        
        return processed_meta

